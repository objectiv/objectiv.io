---
id: bach-api-reference-series-bach-series-materialize
slug: /modeling/bach/api-reference/Series/materialize/
title: materialize
---

# bach.Series.materialize

<div className="method">

### <span className="name">materialize</span>

<small className="parameter-list">(<span className="parameter" id="node_name">node_name='manual_materialize'</span>, <span className="parameter" id="limit">limit=None</span>, <span className="parameter" id="distinct">distinct=False</span>)</small>


&#8203;<span className="view-source">[[source]](https://github.com/objectiv/objectiv-analytics/blob/mainon3.8/site-packages/bach/series/series.py)</span>

<div className="content">

Create a copy of this Series with as base_node the current Series’s state.

This effectively adds a node to the underlying SqlModel graph. Generally adding nodes increases
the size of the generated SQL query. But this can be useful if the current Series contains
expressions that you want to evaluate before further expressions are build on top of them. This might
make sense for very large expressions, or for non-deterministic expressions (e.g. see
`SeriesUuid.sql_gen_random_uuid()`).


#### Parameters

* **`node_name`** – The name of the node that’s going to be created
* **`limit`** (Optional[Any]) – The limit (slice, int) to apply.
* **`distinct`** (bool) – Apply distinct statement if `distinct=True`



#### Returns

Series with the current Series’s state as base_node



#### Return type

[bach.series.series.Series](/modeling/bach/api-reference/Series/bach.Series.mdx)


:::note

Calling materialize() resets the order of the series. Call [`sort_values()`](/modeling/bach/api-reference/Series/bach.Series.sort_values.mdx) again on
the result if order is important.

Argument inplace should be always False.


:::


</div>


</div>
