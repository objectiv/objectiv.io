<div>
                
  <section id="bach-and-sklearn">
<span id="example-machine-learning"/><h1>Bach and sklearn<a class="headerlink" href="#bach-and-sklearn" title="Permalink to this headline">#</a></h1>
<p>With Objectiv you can do all your analysis and Machine Learning directly on the raw data in your SQL database.
This example shows in the simplest way possible how you can use Objectiv to create a basic feature set and use
sklearn to do machine learning on this data set. We also have an example that goes deeper into
feature engineering <a class="reference external" href="feature_engineering.html">here</a>.</p>
<p>This example is also available in a <a class="reference external" href="https://github.com/objectiv/objectiv-analytics/blob/main/notebooks/sklearn-example.ipynb">notebook</a>
to run on your own data or use our
<a class="reference external" href="https://objectiv.io/docs/home/quickstart-guide/">quickstart</a> to try it out with demo data in 5 minutes.</p>
<p>At first we have to install the open model hub and instantiate the Objectiv DataFrame object. See
<a class="reference internal" href="example_notebooks.html#get-started-with-objectiv"><span class="std std-ref">Getting started with Objectiv</span></a> for more info on this.</p>
<p>This object points to all data in the data set. Without any aggregation, this dataset is too large to
for pandas and sklearn. For the data set that we need, we aggregate to user level, at which point it is
small enough to fit in memory.</p>
<p>We create a data set of per user all the root locations that the user clicked on.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="c1"># extract the root location from the location stack</span>
<span class="n">df</span><span class="p">[</span><span class="s1">'root'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">location_stack</span><span class="o">.</span><span class="n">ls</span><span class="o">.</span><span class="n">get_from_context_with_type_series</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">'RootLocationContext'</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">'id'</span><span class="p">)</span>
<span class="c1"># only look at press events and count the root locations</span>
<span class="n">features</span> <span class="o">=</span> <span class="n">features</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="o">.</span><span class="n">event_type</span><span class="o">==</span><span class="s1">'PressEvent'</span><span class="p">)]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'user_id'</span><span class="p">)</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
<span class="c1"># unstack the series, to create a DataFrame with the number of clicks per root location as columns</span>
<span class="n">features_unstacked</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we have a basic feature set that is small enough to fit in memory. This can be used with sklearn, as we
demonstrate in this example.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">cluster</span>

<span class="c1"># export to pandas now</span>
<span class="n">pdf</span> <span class="o">=</span> <span class="n">features_unstacked</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>

<span class="c1"># do the clustering using the pandas DataFrame and set the labels as a column to that DataFrame</span>
<span class="n">est</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">est</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s1">'cluster'</span><span class="p">]</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">labels_</span>
</pre></div>
</div>
<p>Now you can use the created clusters on your entire data set again if you add it back to your DataFrame.
This is simple, as Bach and pandas are cooperating nicely. Your original Objectiv data now has a &#8216;cluster&#8217;
column.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">kfeatures_unstacked</span><span class="p">[</span><span class="s1">'cluster'</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdf</span><span class="p">[</span><span class="s1">'cluster'</span><span class="p">]</span>
<span class="n">df_with_cluster_results</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">features_unstacked</span><span class="p">[[</span><span class="s1">'cluster'</span><span class="p">]],</span> <span class="n">on</span><span class="o">=</span><span class="s1">'user_id'</span><span class="p">)</span>
</pre></div>
</div>
<p>You can use this column, just as any other. For example you can now use your created clusters to group models
from the model hub by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span/><span class="n">df_with_cluster</span><span class="o">.</span><span class="n">mh</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">session_duration</span><span class="p">(</span><span class="n">groupby</span><span class="o">=</span><span class="s1">'cluster'</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="c1"># Expected output:</span>
<span class="c1"># cluster</span>
<span class="c1"># 0   0 days 00:09:18.204353</span>
<span class="c1"># 1   0 days 00:10:25.104636</span>
<span class="c1"># 2   0 days 00:20:43.561232</span>
<span class="c1"># Name: session_duration, dtype: timedelta64[ns]</span>
</pre></div>
</div>
</section>


              </div>
              
              
              