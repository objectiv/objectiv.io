<div>
                
  <section id="bach-dataframe-materialize">
<h1>bach.DataFrame.materialize<a class="headerlink" href="#bach-dataframe-materialize" title="Permalink to this headline">&#182;</a></h1>
<dl class="py method">
<dt class="sig sig-object py" id="bach.DataFrame.materialize">
<span class="sig-prename descclassname"><span class="pre">DataFrame.</span></span><span class="sig-name descname"><span class="pre">materialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'manual_materialize'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/objectiv/objectiv-analytics/blob/mainach/bach/dataframe.py"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bach.DataFrame.materialize" title="Permalink to this definition">&#182;</a></dt>
<dd><p>Create a copy of this DataFrame with as base_node the current DataFrame&#8217;s state.</p>
<p>This effectively adds a node to the underlying SqlModel graph. Generally adding nodes increases
the size of the generated SQL query. But this can be useful if the current DataFrame contains
expressions that you want to evaluate before further expressions are build on top of them. This might
make sense for very large expressions, or for non-deterministic expressions (e.g. see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">SeriesUuid.sql_gen_random_uuid()</span></code>).</p>
<p>TODO: a known problem is that DataFrames with &#8216;json&#8217; columns cannot be fully materialized.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_name</strong> &#8211; The name of the node that&#8217;s going to be created</p></li>
<li><p><strong>inplace</strong> &#8211; Perform operation on self if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>, or create a copy.</p></li>
<li><p><strong>limit</strong> (<em>Optional</em><em>[</em><em>Any</em><em>]</em>) &#8211; The limit (slice, int) to apply.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>DataFrame with the current DataFrame&#8217;s state as base_node</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="bach.DataFrame.html#bach.DataFrame" title="bach.dataframe.DataFrame">bach.dataframe.DataFrame</a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling materialize() resets the order of the dataframe. Call <a class="reference internal" href="bach.DataFrame.sort_values.html#bach.DataFrame.sort_values" title="bach.DataFrame.sort_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_values()</span></code></a> again on
the result if order is important.</p>
</div>
</dd></dl>

</section>


              </div>
              
              
              